//
//  CitySearchInteractorTests.swift
//  PocketWorksWeather
//
//  Created by Anh Phan Tran on 27/07/2019.
//  Copyright (c) 2019 Anh Phan Tran. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

@testable import PocketWorksWeather
import Quick
import Nimble
import Promises

class CitySearchInteractorSpec: QuickSpec {
  // MARK: - Subject under test:
  var sut: CitySearchInteractor!

  // MARK: - Test doubles:
  class CitySearchPresentationLogicSpy: CitySearchPresentationLogic {
    var presentUpdateResultsCalled = false
    var presentUpdateResultsCount = 0
    var presentUpdateResultsResponse: CitySearch.UpdateResults.Response?
    var presentValidatingCityNameResponses = [Bool]()
    var presentSelectCityCalled = false

    func presentUpdateResults(_ response: CitySearch.UpdateResults.Response) {
      self.presentUpdateResultsCount += 1
      self.presentUpdateResultsCalled = true
      self.presentUpdateResultsResponse = response
    }

    func presentValidatingCityName(_ response: CitySearch.ValidatingCityName.Response) {
      self.presentValidatingCityNameResponses.append(response.isValidating)
    }

    func presentSelectCity(_ response: CitySearch.SelectCity.Response) {
      self.presentSelectCityCalled = true
    }
  }

  class CitySearchWorkerSpy: CitySearchWorker {
    var searchForCityCalled = false

    override func searchForCity(using term: String) -> Promise<[PWCity]> {
      self.searchForCityCalled = true

      if term == Seed.hanoi.name {
        return Promise([Seed.hanoi])
      }

      return Promise([])
    }
  }

  // MARK: - Spec:
  override func spec() {
    describe("CitySearchInteractor") {
      beforeEach {
        self.sut = CitySearchInteractor()
      }

      context("when updating result") {
        it("should toggle validating city to true and false") {
          let request = CitySearch.UpdateResults.Request(searchTerm: "some term")
          let spy = CitySearchPresentationLogicSpy()
          self.sut.presenter = spy
          self.sut.worker = CitySearchWorkerSpy(cityListProvider: StubbedCityListProvider())

          self.sut.updateResults(request)

          expect(spy.presentValidatingCityNameResponses.count).toEventually(equal(2), timeout: 10)
          expect(spy.presentValidatingCityNameResponses).toEventually(equal([true, false]), timeout: 10)
        }

        it("should ask worker to find results") {
          let request = CitySearch.UpdateResults.Request(searchTerm: "some term")
          let spy = CitySearchWorkerSpy(cityListProvider: StubbedCityListProvider())
          self.sut.worker = spy
          
          self.sut.updateResults(request)

          expect(spy.searchForCityCalled).toEventually(be(true))
        }

        it("should ask presenter to present results when results are found") {
          let request = CitySearch.UpdateResults.Request(searchTerm: "some term")
          let presenterSpy = CitySearchPresentationLogicSpy()
          let workerSpy = CitySearchWorkerSpy(cityListProvider: StubbedCityListProvider())
          self.sut.presenter = presenterSpy
          self.sut.worker = workerSpy

          self.sut.updateResults(request)

          expect(presenterSpy.presentUpdateResultsCalled).toEventually(be(true))
          expect(presenterSpy.presentUpdateResultsResponse).toEventuallyNot(beNil())
          expect(presenterSpy.presentUpdateResultsResponse?.results).toEventually(beEmpty())
        }

        it("should ask presenter to present results when results are found") {
          let request = CitySearch.UpdateResults.Request(searchTerm: Seed.hanoi.name)
          let presenterSpy = CitySearchPresentationLogicSpy()
          let workerSpy = CitySearchWorkerSpy(cityListProvider: StubbedCityListProvider())
          self.sut.presenter = presenterSpy
          self.sut.worker = workerSpy
          
          self.sut.updateResults(request)
          
          expect(presenterSpy.presentUpdateResultsCalled).toEventually(be(true))
          expect(presenterSpy.presentUpdateResultsResponse).toEventuallyNot(beNil())
          expect(presenterSpy.presentUpdateResultsResponse?.results).toEventuallyNot(beEmpty())
        }

        it("should not ask presenter to present results when search term is updated") {
          let request = CitySearch.UpdateResults.Request(searchTerm: Seed.hanoi.name)
          let anotherRequest = CitySearch.UpdateResults.Request(searchTerm: "some terms")
          let presenterSpy = CitySearchPresentationLogicSpy()
          self.sut.presenter = presenterSpy
          let workerSpy = CitySearchWorkerSpy(cityListProvider: StubbedCityListProvider())
          self.sut.worker = workerSpy
          
          self.sut.updateResults(request)
          self.sut.updateResults(anotherRequest)

          expect(presenterSpy.presentUpdateResultsCount).toEventually(be(1), timeout: 10)
          expect(presenterSpy.presentUpdateResultsCount).toEventuallyNot(be(2), timeout: 10)
        }
      }
    }
    
    context("when selecting a city") {
      it("should return if selected index is invalid") {
        let spy = CitySearchPresentationLogicSpy()
        self.sut.presenter = spy
        let request = CitySearch.SelectCity.Request(selectedIndex: -1)

        self.sut.selectCity(request)

        expect(spy.presentSelectCityCalled).toEventually(beFalse(), timeout: 3.0)
      }

      it("should return if selected index is out of bound") {
        let spy = CitySearchPresentationLogicSpy()
        self.sut.presenter = spy
        let request = CitySearch.SelectCity.Request(selectedIndex: 2)
        self.sut.currentResults = [Seed.hanoi]

        self.sut.selectCity(request)
        
        expect(spy.presentSelectCityCalled).toEventually(beFalse(), timeout: 3.0)
      }

      it("should assign selected city value and ask presenter to present") {
        let spy = CitySearchPresentationLogicSpy()
        self.sut.presenter = spy
        let request = CitySearch.SelectCity.Request(selectedIndex: 0)
        self.sut.currentResults = [Seed.hanoi]

        self.sut.selectCity(request)

        expect(spy.presentSelectCityCalled).to(beTrue())
        expect(self.sut.selectedCity?.id).to(equal(Seed.hanoi.id))
      }
    }
  }
}
