//
//  CitySearchViewControllerTests.swift
//  PocketWorksWeather
//
//  Created by Anh Phan Tran on 27/07/2019.
//  Copyright (c) 2019 Anh Phan Tran. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

@testable import PocketWorksWeather
import Quick
import Nimble

class CitySearchViewControllerSpec: QuickSpec {
  // MARK: - Subject under test:
  var sut: CitySearchViewController!
  var window: UIWindow!

  // MARK: - Test doubles:
  class CitySearchBusinessLogicSpy: CitySearchBusinessLogic {
    var selectCityCalled = false
    var selectCityRequest: CitySearch.SelectCity.Request?
    var updateResultsCalled = false
    var updateResultsRequest: CitySearch.UpdateResults.Request?
    func updateResults(_ request: CitySearch.UpdateResults.Request) {
      self.updateResultsCalled = true
      self.updateResultsRequest = request
    }
    func selectCity(_ request: CitySearch.SelectCity.Request) {
      self.selectCityCalled = true
      self.selectCityRequest = request
    }
  }
  
  class CitySearchRouterSpy: CitySearchRouter {
    var routeBackToCityListCalled = false
    override func routeBackToCityListWithSelectedCity() {
      self.routeBackToCityListCalled = true
    }
  }

  class CollectionViewSpy: UICollectionView {
    var reloadDataCalled = false

    override func reloadData() {
      self.reloadDataCalled = true
      super.reloadData()
    }
  }

  // MARK: - Spec:
  override func spec() {
    describe("CitySearchViewController") {
      beforeEach {
        self.window = UIWindow()
        let bundle = Bundle.main
        let storyboard = UIStoryboard(name: "Main", bundle: bundle)
        self.sut = storyboard.instantiateViewController(withIdentifier: "CitySearchViewController") as? CitySearchViewController
      }

      afterEach {
        self.window = nil
      }

      func loadView() {
        self.window.addSubview(self.sut.view)
        RunLoop.current.run(until: Date())
      }

      context("when loaded") {
        it("should ask search bar to become first responder") {
          loadView()

          expect(self.sut.searchBar.isFirstResponder).toEventually(beTrue())
        }
      }

      context("when search bar text changed") {
        it("should ask interactor to update results") {
          loadView()
          let spy = CitySearchBusinessLogicSpy()
          self.sut.interactor = spy

          self.sut.searchBar(self.sut.searchBar!, textDidChange: "some string")

          expect(spy.updateResultsCalled).to(beTrue())
          expect(spy.updateResultsRequest).toNot(beNil())
          expect(spy.updateResultsRequest?.searchTerm).to(equal("some string"))
        }
      }

      context("when displaying update results") {
        it("should update results list") {
          loadView()
          let collectionViewSpy = CollectionViewSpy(frame: CGRect.zero, collectionViewLayout: UICollectionViewFlowLayout())
          self.sut.resultCollectionView = collectionViewSpy
          let cityNameString = NSAttributedString(string: "someString").applyForegroundColor(.red)
          let result = CitySearchResultCell.ViewModel(cityName: cityNameString)
          let viewModel = CitySearch.UpdateResults.ViewModel(results: [result])

          self.sut.displayUpdateResults(viewModel)

          expect(self.sut.results.count).to(equal(1))
          expect(collectionViewSpy.reloadDataCalled).toEventually(beTrue())
          expect(collectionViewSpy.backgroundView).to(beNil())
        }
  
        it("should update collection view with collection data") {
          loadView()
          let cityNameString = NSAttributedString(string: "someString").applyForegroundColor(.red)
          let result = CitySearchResultCell.ViewModel(cityName: cityNameString)
          let viewModel = CitySearch.UpdateResults.ViewModel(results: [result])
          
          self.sut.displayUpdateResults(viewModel)

          let numberOfSections = self.sut.numberOfSections(in: self.sut.resultCollectionView)
          expect(numberOfSections).to(equal(1))
          
          let numberOfRows = self.sut.collectionView(self.sut.resultCollectionView, numberOfItemsInSection: 0)
          expect(numberOfRows).to(equal(1))
          
          let indexPath = IndexPath(row: 0, section: 0)
          let cell = self.sut.collectionView(self.sut.resultCollectionView, cellForItemAt: indexPath)
          expect(cell).to(beAKindOf(CitySearchResultCell.self))
          
          let resultCell = cell as? CitySearchResultCell
          expect(resultCell?.cityNameLabel.attributedText).to(equal(cityNameString))
        }

        it("should show message when no result is found") {
          loadView()
          self.sut.searchBar.text = "some text"
          let viewModel = CitySearch.UpdateResults.ViewModel(results: [])

          self.sut.displayUpdateResults(viewModel)

          expect(self.sut.resultCollectionView.backgroundView).toNot(beNil())
          expect(self.sut.validatingView?.messageLabel.text).to(equal("No results found."))
        }

        it("should not show message when no result is found but text field is empty") {
          loadView()
          self.sut.searchBar.text = ""
          let viewModel = CitySearch.UpdateResults.ViewModel(results: [])
          
          self.sut.displayUpdateResults(viewModel)
          
          expect(self.sut.resultCollectionView.backgroundView).to(beNil())
        }
      }

      context("when displaying validating city name") {
        it("should show message when validating city name") {
          loadView()
          let collectionViewSpy = CollectionViewSpy(frame: CGRect.zero, collectionViewLayout: UICollectionViewFlowLayout())
          self.sut.resultCollectionView = collectionViewSpy
          let viewModel = CitySearch.ValidatingCityName.ViewModel(isValidating: true)
          
          self.sut.displayValidatingCityName(viewModel)

          expect(self.sut.results).to(beEmpty())
          expect(collectionViewSpy.reloadDataCalled).to(beTrue())
          expect(self.sut.validatingView?.messageLabel.text).to(equal("Validating city ..."))
          expect(collectionViewSpy.backgroundView).toNot(beNil())
        }

        it("should not show message when not validating city name") {
          loadView()
          let viewModel = CitySearch.ValidatingCityName.ViewModel(isValidating: false)
          
          self.sut.displayValidatingCityName(viewModel)

          expect(self.sut.resultCollectionView.backgroundView).to(beNil())
        }
      }

      context("when a city is selected from table view") {
        it("should ask interactor to select city") {
          loadView()
          let spy = CitySearchBusinessLogicSpy()
          self.sut.interactor = spy
          let cityNameString = NSAttributedString(string: "someString").applyForegroundColor(.red)
          let result = CitySearchResultCell.ViewModel(cityName: cityNameString)
          let viewModel = CitySearch.UpdateResults.ViewModel(results: [result])
          self.sut.displayUpdateResults(viewModel)

          let selectedIndexPath = IndexPath(row: 0, section: 0)
          self.sut.collectionView(self.sut.resultCollectionView, didSelectItemAt: selectedIndexPath)

          expect(spy.selectCityCalled).to(beTrue())
          expect(spy.selectCityRequest).toNot(beNil())
          expect(spy.selectCityRequest?.selectedIndex).to(equal(selectedIndexPath.row))
        }
      }

      context("when displaying a selected city") {
        it("should ask router to route back to city list") {
          loadView()
          let spy = CitySearchRouterSpy()
          self.sut.router = spy
          let viewModel = CitySearch.SelectCity.ViewModel()

          self.sut.displaySelectCity(viewModel)

          expect(spy.routeBackToCityListCalled).to(beTrue())
        }
      }
    }
  }
}
