//
//  CitySearchViewController.swift
//  PocketWorksWeather
//
//  Created by Anh Phan Tran on 27/07/2019.
//  Copyright (c) 2019 Anh Phan Tran. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol CitySearchDisplayLogic: class {
  func displayUpdateResults(_ viewModel: CitySearch.UpdateResults.ViewModel)
  func displayValidatingCityName(_ viewModel: CitySearch.ValidatingCityName.ViewModel)
  func displaySelectCity(_ viewModel: CitySearch.SelectCity.ViewModel)
}

class CitySearchViewController: UIViewController, CitySearchDisplayLogic, StoryboardBased {
  static var storyboardName: String {
    return "Main"
  }

  override var preferredStatusBarStyle: UIStatusBarStyle {
    return .lightContent
  }

  // MARK: - IBOutlets:
  @IBOutlet weak var searchBar: UISearchBar!
  @IBOutlet weak var resultCollectionView: UICollectionView!

  // MARK: - IBActions:

  // MARK: - Model:
  var interactor: CitySearchBusinessLogic?
  var router: (NSObjectProtocol & CitySearchRoutingLogic & CitySearchDataPassing)?
  var results: [CitySearchResultCell.ViewModel] = []

  lazy var validatingView = CitySearchResultBackgroundView.loadFromXib()

  // MARK: - View Life Cycle:
  override func viewDidLoad() {
    super.viewDidLoad()
    self.setupUIOnLaunch()
  }

  override func viewDidAppear(_ animated: Bool) {
    super.viewDidAppear(animated)
    self.searchBar.becomeFirstResponder()
  }

  // MARK: - Public Funcs (Use cases):
  func displayUpdateResults(_ viewModel: CitySearch.UpdateResults.ViewModel) {
    self.results = viewModel.results
    self.resultCollectionView.reloadData()
    if results.isEmpty && self.searchBar.text?.isEmpty == false {
      self.validatingView?.messageLabel.text = "No results found."
      self.resultCollectionView.backgroundView = self.validatingView
    } else {
      self.resultCollectionView.backgroundView = nil
    }
  }

  func displayValidatingCityName(_ viewModel: CitySearch.ValidatingCityName.ViewModel) {
    if viewModel.isValidating {
      self.results = []
      self.resultCollectionView.reloadData()
      self.validatingView?.messageLabel.text = "Validating city ..."
      self.resultCollectionView.backgroundView = self.validatingView
    } else {
      self.resultCollectionView.backgroundView = nil
    }
  }

  func displaySelectCity(_ viewModel: CitySearch.SelectCity.ViewModel) {
    self.router?.routeBackToCityListWithSelectedCity()
  }

  // MARK: - Private Funcs:
  private func setupUIOnLaunch() {
    self.setupResultCollectionView()
    self.setupSearchBar()
  }

  private func setupResultCollectionView() {
    self.resultCollectionView.register(CitySearchResultCell.nib, forCellWithReuseIdentifier: CitySearchResultCell.identifier)
    self.resultCollectionView.dataSource = self
    self.resultCollectionView.delegate = self
  }

  private func setupSearchBar() {
    self.searchBar.delegate = self
    self.searchBar.showsCancelButton = true
  }

  // MARK: - VIP Setup:
  override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
    super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
    setup()
  }

  required init?(coder aDecoder: NSCoder) {
    super.init(coder: aDecoder)
    setup()
  }

  private func setup() {
    let viewController = self
    let interactor = CitySearchInteractor()
    let presenter = CitySearchPresenter()
    let router = CitySearchRouter()
    viewController.interactor = interactor
    viewController.router = router
    interactor.presenter = presenter
    presenter.viewController = viewController
    router.viewController = viewController
    router.dataStore = interactor
  }
}

extension CitySearchViewController: UISearchBarDelegate {
  func searchBar(_ searchBar: UISearchBar, textDidChange searchText: String) {
    let request = CitySearch.UpdateResults.Request(searchTerm: searchText)
    self.interactor?.updateResults(request)
  }

  func searchBarCancelButtonClicked(_ searchBar: UISearchBar) {
    searchBar.endEditing(false)
    self.dismiss(animated: true, completion: nil)
  }
}

extension CitySearchViewController: UICollectionViewDataSource {
  func numberOfSections(in collectionView: UICollectionView) -> Int {
    return 1
  }

  func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
    return self.results.count
  }

  func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
    guard
      let cell = collectionView.dequeueReusableCell(withReuseIdentifier: CitySearchResultCell.identifier, for: indexPath) as? CitySearchResultCell
    else {
      fatalError("cell not configured")
    }

    cell.viewModel = self.results[indexPath.row]
    return cell
  }
}

extension CitySearchViewController: UICollectionViewDelegate {
  func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {
    let selectedIndex = indexPath.row
    let request = CitySearch.SelectCity.Request(selectedIndex: selectedIndex)
    self.interactor?.selectCity(request)
  }
}
