//
//  CityDetailsViewController.swift
//  PocketWorksWeather
//
//  Created by Anh Phan Tran on 28/07/2019.
//  Copyright (c) 2019 Anh Phan Tran. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol CityDetailsDisplayLogic: class {
  func displayShowWeather(_ viewModel: CityDetails.ShowWeather.ViewModel)
  func displayGetForecastData(_ viewModel: CityDetails.GetForecastData.ViewModel)
  func displayToggleForecastLoading(_ viewModel: CityDetails.ToggleForecastLoading.ViewModel)
  func displayShowError(_ viewModel: CityDetails.ShowError.ViewModel)
}

class CityDetailsViewController: UIViewController, CityDetailsDisplayLogic, RouteDataBased {
  static var storyboardName: String {
    return "Main"
  }

  override var preferredStatusBarStyle: UIStatusBarStyle {
    return .lightContent
  }

  struct RouteData {
    var city: PWCity
    var weatherData: CityWeatherResponse
  }

  // MARK: - IBOutlets:
  @IBOutlet weak var contentScrollView: UIScrollView!
  @IBOutlet weak var cityNameLabel: UILabel!
  @IBOutlet weak var mainWeatherLabel: UILabel!
  @IBOutlet weak var windInfoLabel: UILabel!
  @IBOutlet weak var weekDayLabel: UILabel!
  @IBOutlet weak var maximumTempLabel: UILabel!
  @IBOutlet weak var minimumTempLabel: UILabel!
  @IBOutlet weak var weatherDescriptionLabel: UILabel!
  @IBOutlet weak var currentTemperatureLabel: UILabel!
  @IBOutlet weak var humidityLabel: UILabel!
  @IBOutlet weak var sunriseLabel: UILabel!
  @IBOutlet weak var sunsetLabel: UILabel!
  @IBOutlet weak var pressureLabel: UILabel!
  @IBOutlet weak var visibilityLabel: UILabel!
  @IBOutlet weak var activityIndicator: UIActivityIndicatorView!
  @IBOutlet weak var forecastsCollectionView: UICollectionView!
  @IBOutlet weak var contentStackView: UIStackView!

  // MARK: - IBActions:
  @IBAction func back() {
    self.dismiss(animated: true, completion: nil)
  }

  @IBAction func openWeatherData() {
    if
      let openWeatherURL = self.interactor?.openWeatherURL,
      UIApplication.shared.canOpenURL(openWeatherURL)
    {
      UIApplication.shared.open(openWeatherURL, options: [:], completionHandler: nil)
    }
  }

  // MARK: - Model:
  var interactor: CityDetailsBusinessLogic?
  var router: (NSObjectProtocol & CityDetailsRoutingLogic & CityDetailsDataPassing)?
  let transitionDelegate = CityDetailsTransitionDelegate()
  var forecastsVMs: [WindForecastCell.ViewModel] = []

  // MARK: - View Life Cycle:
  override func viewDidLoad() {
    super.viewDidLoad()
    self.setupUIOnLaunch()
    self.showWeatherOnLaunch()
  }

  // MARK: - Public Funcs (Use cases):
  func displayGetForecastData(_ viewModel: CityDetails.GetForecastData.ViewModel) {
    self.forecastsVMs = viewModel.forecastVMs
    self.forecastsCollectionView.reloadData()
  }

  func displayShowWeather(_ viewModel: CityDetails.ShowWeather.ViewModel) {
    self.cityNameLabel.text = viewModel.cityName
    self.mainWeatherLabel.text = viewModel.mainWeather
    self.windInfoLabel.attributedText = viewModel.windInfo
    self.weekDayLabel.text = viewModel.weekDay
    self.maximumTempLabel.text = viewModel.maximumTemp
    self.minimumTempLabel.text = viewModel.minimumTemp
    self.weatherDescriptionLabel.text = viewModel.weatherDescription
    self.currentTemperatureLabel.text = viewModel.currentTemperature
    self.humidityLabel.text = viewModel.humidityLevel
    self.sunriseLabel.text = viewModel.sunrise
    self.sunsetLabel.text = viewModel.sunset
    self.pressureLabel.text = viewModel.pressure
    self.visibilityLabel.text = viewModel.visibility

    let request = CityDetails.GetForecastData.Request()
    self.interactor?.getForecastsData(request)
  }

  func displayToggleForecastLoading(_ viewModel: CityDetails.ToggleForecastLoading.ViewModel) {
    viewModel.isLoading ?
      self.activityIndicator.startAnimating() :
      self.activityIndicator.stopAnimating()
  }

  func displayShowError(_ viewModel: CityDetails.ShowError.ViewModel) {
    self.alert(title: "Error", message: viewModel.errorString) {
      self.reloadForecastData()
    }
  }

  func reloadForecastData() {
    let request = CityDetails.GetForecastData.Request()
    self.interactor?.getForecastsData(request)
  }

  // MARK: - Private Funcs:
  private func setupUIOnLaunch() {
    self.setupScrollView()
    self.setupForecastsCollectionView()
  }

  private func showWeatherOnLaunch() {
    let request = CityDetails.ShowWeather.Request()
    self.interactor?.showWeather(request)
  }

  private func setupScrollView() {
    self.contentScrollView.contentInset = UIEdgeInsets(top: 20, left: 0, bottom: 20, right: 0)
  }

  private func setupForecastsCollectionView() {
    self.forecastsCollectionView.register(WindForecastCell.nib, forCellWithReuseIdentifier: WindForecastCell.identifier)
    self.forecastsCollectionView.dataSource = self
  }

  // MARK: - VIP Setup:
  override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
    super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
    setup()
  }

  required init?(coder aDecoder: NSCoder) {
    super.init(coder: aDecoder)
    setup()
  }

  private func setup() {
    let viewController = self
    let interactor = CityDetailsInteractor()
    let presenter = CityDetailsPresenter()
    let router = CityDetailsRouter()
    viewController.interactor = interactor
    viewController.router = router
    interactor.presenter = presenter
    presenter.viewController = viewController
    router.viewController = viewController
    router.dataStore = interactor
    self.transitioningDelegate = self.transitionDelegate
  }

  func configure(with passedData: RouteData) {
    var dataStore = self.router?.dataStore
    dataStore?.weatherData = passedData.weatherData
    dataStore?.city = passedData.city
  }
}

extension CityDetailsViewController: UICollectionViewDataSource {
  func numberOfSections(in collectionView: UICollectionView) -> Int {
    return 1
  }

  func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
    return self.forecastsVMs.count
  }

  func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
    guard let cell = collectionView.dequeueReusableCell(withReuseIdentifier: WindForecastCell.identifier, for: indexPath) as? WindForecastCell else {
      fatalError("cell not configured")
    }

    cell.viewModel = self.forecastsVMs[indexPath.row]

    return cell
  }
}
